# 2025.01.21 TIL
### SQL 중급(순위 함수, 윈도우함수, 계층 쿼리)
순위 함수, 윈도우 함수, 계층 쿼리에 대해서 배우고 쿼리를 작성하는 시간을 가졌습니다.
저번 시간에 개념만 배웠던 순위 함수에 대해서 실습을 통해 더 깊게 이해하는 시간을 가졌습니다.
또한 윈도우 함수와 관련해서 강사님께서 총 10개의 문제를 조별로 풀고 서로 공유해보는 시간을 가졌습니다.
윈도우 함수는 제가 이전 스타트업에서도 많이 사용해 본 적 없어서 익숙하지 않은데 문제를 풀어보면서 꽤 이해도가 높아진 것 같습니다.
계층 쿼리는 우선 개념에 대해서 배우고 예제 쿼리를 따라서 작성해보는 시간만 가졌습니다. 다음 시간에 문제를 풀면서 이해도가 높아질 것 같습니다.

아래에 오늘 작성한 문제들의 쿼리 첨부합니다.
```MYSQL
-- 1.
select * from (
select job_id, employee_id, name, salary, rank() over(partition by job_id order by salary desc) as rank 
from employees 
where salary is not null
)
where rank <= 3;

-- 2.
select distinct to_char(hire_date, 'YYYY'),
(select sum(salary) from employees 
group by to_char(hire_date, 'YYYY') having to_char(hire_date, 'YYYY') = to_char(e1.hire_date, 'YYYY')) as total_salary,
sum(salary) over(order by to_char(hire_date, 'YYYY')) as cumulative_salary
from employees e1;

-- 3.
select t.employee_id, t.name, t.salary, t.rank, t.department_avg,
case
when t.salary > t.department_avg then '높다'
when t.salary < t.department_avg then '낮다'
end as 여부
from
(
select employee_id, name, salary, rank() over(order by salary desc) as rank, 
(select avg(salary) from employees e
inner join departments d
on e.department_id = d.department_id
group by d.department_id
having d.department_id = e1.department_id) as department_avg
from employees e1
) t;


-- 4.
select  c.name, t1.total_amount from
(
select t.customer_id, t.total_amount, rank() over(order by total_amount desc) as rank from
(
select distinct l.customer_id, sum(l.amount) over(partition by l.customer_id) as total_amount from loans l
where add_months(sysdate, -12) <= loan_date
) t
) t1, customers c
where c.customer_id = t1.customer_id and t1.rank <=5;

-- 5.
select employee_id, name, salary,
round(avg(salary) over(order by employee_id rows 2 preceding),2) as move_avg
from employees;


-- 6.
select a.balance, c.name, '계좌' from accounts a
left outer join customers c
on a.customer_id = c.customer_id
where a.balance >= (select avg(balance) from accounts)
union all
select l.amount, c.name, '대출' from loans l
left outer join customers c
on l.customer_id = c.customer_id
where l.amount >= (select avg(amount) from loans);

-- 7.
select distinct * from
(
select e.job_id, d.department_name, 
round(avg(salary) over(partition by e.job_id),0) as salary_job_avg, 
round(avg(salary) over(partition by d.department_id),0) as salary_department_avg from employees e
inner join departments d
on e.department_id = d.department_id
) t
where t.salary_job_avg >= salary_department_avg;

-- 8.
select distinct t.branch_id, round(t.approve_loan_count/t.loan_total_count*100, 2) as approve_per from
(
select branch_id,
count(loan_id) over(partition by branch_id) as loan_total_count,
(select count(loan_id) from loans where branch_id = l.branch_id and status = 'APPROVED') as approve_loan_count
from loans l
) t;

-- 9.
select name, salary from employees
where (job_id, salary) in
(select job_id, max(salary) over(partition by job_id) as max_salary from employees)
order by job_id;

-- 10.
select d.department_id, d.department_name,
(select count(employee_id) from employees where department_id = d.department_id and manager_id is not null) as good_manager,
(select count(employee_id) from employees where department_id = d.department_id and manager_id is null) as no_manager
from departments d;

select d.department_name, count(*) - count(e.manager_id) as no_manager, count(e.manager_id) as good_manager from employees e
left outer join departments d
on e.department_id = d.department_id
group by d.department_name;




```
